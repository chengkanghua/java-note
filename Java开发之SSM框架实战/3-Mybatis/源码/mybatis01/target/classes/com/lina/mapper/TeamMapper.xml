<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--映射文件：实体类与数据库表的映射  ORM思想 object relation mapping
        SQL语句从代码的硬编码中抽取出来了
    -->
<!--namespace=“完全限定名，接口的完全限定名”-->
<mapper namespace="com.lina.mapper.TeamMapper">
    <cache>
        <property name="eviction" value="LRU"/><!--回收策略为LRU-->
        <property name="flushInterval" value="60000"/><!--自动刷新时间间隔为60S-->
        <property name="size" value="1024"/><!--最多缓存1024个引用对象-->
        <property name="readOnly" value="true"/><!--只读-->
    </cache>
    <delete id="delList" >
        delete from team where teamId  in
        <!--collection:要遍历的集合；参数是集合类型，直接写list
        item:遍历的集合中的每一个数据
        separator：将遍历的结果用，分割
        open="(" close=")"：表示将遍历结果用open close包裹起来-->
        <foreach collection="list" item="teamId" separator="," open="(" close=")">
            #{teamId}
        </foreach>
    </delete>
    <!--批量添加-->
    <insert id="addList" parameterType="arraylist">
        INSERT INTO team (teamName,location) VALUES
        <!--collection:要遍历的集合；参数是集合类型，直接写list
        item:遍历的集合中的每一个数据
        separator：将遍历的结果用，分割-->
        <foreach collection="list" item="t" separator=",">
            (#{t.teamName},#{t.location})
        </foreach>
    </insert>
    <!--多条件查询：
        模糊查询的写法可以使用3种方式：
        方式1： and teamName like #{name} ,传递参数的时候带上%，例如vo.setName("%人%")
        方式2： and teamName like ‘%${name}%’ 传递参数的时候没有%，例如vo.setName("人")
        方式3：  and teamName like concat(concat('%',#{name}),'%')  例如vo.setName("人")
            concat(str1,str2)函数是字符串拼接使用-->
    <select id="queryByVO" parameterType="QueryVO" resultMap="baseResultMap" useCache="false">
        select * from team
        <where>
            <!-- 如果用户输入了名称，就模糊查询   and teamName like '%?%'-->
            <if test="name!=null ">
                and teamName like concat(concat('%',#{name}),'%')
            </if>
            <if test="beginTime!=null ">
                and createTime>=#{beginTime}
            </if>
            <if test="endTime!=null ">
                and createTime&lt;=#{endTime}
            </if>
            <if test="location!=null ">
                and location=#{location}
            </if>
        </where>
    </select>

    <!--返回类型可以是基本类型：要求返回的数据必须是单行,如果是单行多列，也取不到后面的列的值,
    如果返回多行报异常：TooManyResultsException-->
    <select id="getCount" resultType="int">
        select count(teamId)from team
    </select>

    <select id="getTwoColumn" resultType="hashmap">
        select count(teamId) as 'sum',max(teamId) as 'max' from team
    </select>
    <select id="getTwoColumnList" resultType="java.util.HashMap">
        select count(teamId) as 'sum',max(teamId) as 'max' from team group by location;
    </select>

    <select id="queryByName" resultType="team">
        select * from team where teamName=#{teamName}
    </select>
    <select id="queryByLocation" resultType="com.lina.pojo.Team">
        select * from team where location=#{location}
    </select>

    <select id="queryByFiled" resultType="com.lina.pojo.Team">
        select * from team where ${column}=#{columnValue}
    </select>

    <!--细节1：
        mybatis3.3版本之前：可以直接写#{0} #{1}
        从mybatis3.4开始：#{arg0} #{arg1}... 或者是 #{param1} #{param2}...
        细节2：sql语句中不能使用小于号，使用转移符号替换;大于号没有限制，也可以使用转义符号替换 &gt;
    -->
    <select id="queryByRange1" resultType="com.lina.pojo.Team">
        select * from team
        where teamId>=#{param1} and teamId&lt;=#{param2}
    </select>
    <!--
    方式2：#{}中的名称必须与接口的方法中的参数注解@Param()保持一致-->
    <select id="queryByRange2" resultType="com.lina.pojo.Team">
        select * from team
        where teamId>=#{min} and teamId&lt;=#{max}
    </select>

    <!--
    方式3：#{}中的名称必须Map集合中的key保持一致-->
    <select id="queryByRange3" resultType="com.lina.pojo.Team">
        select * from team
        where teamId>=#{min} and teamId&lt;=#{max}
    </select>

    <!--
    方式4：#{}中的名称必须pojo的参数的属性保持一致-->
    <select id="queryByCondition" resultType="com.lina.pojo.Team">
        select * from team
        where teamId>=#{min} and teamId&lt;=#{max}
        and teamName like #{name} and location=#{location}
    </select>

    <delete id="del" >
        delete from team where teamId=#{id}
    </delete>

    <update id="update" parameterType="com.lina.pojo.Team">
        update team set teamName=#{teamName},location=#{location},createTime=#{createTime}
        where teamId=#{teamId}
    </update>

    <update id="update1" parameterType="com.lina.pojo.Team">
        update team
        <set>
            <if test="teamName!=null">
                teamName=#{teamName},
            </if>
            <if test="location!=null">
                location=#{location},
            </if>
            <if test="createTime!=null">
                createTime=#{createTime},
            </if>
        </set>
        where teamId=#{teamId}
    </update>

    <!--添加一个球队
    parameterType="com.lina.pojo.Team" 将对象作为参数，
    #{值} 值必须是实体类中的属性名称，其实就是占位符？
    -->
    <insert id="add" parameterType="com.lina.pojo.Team" >
        <!--新增成功之后将自增的ID赋值给参数属性teamId
        keyProperty:表示新增的id值赋值到哪个属性值红
        order：AFTER/BEFORE两个取值，表示selectKey中的sql语句在insert语句之前还是之后执行
        resultType：表示返回值类型
        -->
        <selectKey keyProperty="teamId" order="AFTER" resultType="java.lang.Integer">
            select LAST_INSERT_ID()
        </selectKey>
        INSERT INTO `team` (`teamName`, `location`, `createTime`)
        VALUES (#{teamName}, #{location}, #{createTime})
    </insert>

    <!--id：自定义的名，不能重复；相当于原来的dao中的方法名称
        resultType="返回的类型，如果是集合的时候，写的是集合中的元素的类型"；使用要求：实体类中的属性和表中的列名一致
     -->
    <select id="queryAll" resultType="com.lina.pojo.Team">
        select * from team
    </select>

    <!--parameterType:表示参数的类型，参数唯一的时候才使用该属性；可以省略的，框架可以自己判定类型
        #{自定义的参数名称} 名称没有实际意义
        select * from team where teamId=#{id}等价于

        select * from team where teamId=?
        PreparedStatement ps=conn......;
        ps.setInt(1,teamId);
      -->
    <select id="queryById" parameterType="java.lang.Integer" resultType="com.lina.pojo.Team">
        select * from team where teamId=#{id}
    </select>


    <!--resultMap 和resultType不能同时出现
    resultMap：是引用的自己创建resultMap的id-->
    <select id="queryAll2" resultMap="baseResultMap">
        select * from team;
    </select>
    <!--创建resultMap：相当于自己编写表中的列与实体类中的属性的映射
        id:resultMap的名称，要求唯一
        type：期待要映射为java的类型
    -->
    <resultMap id="baseResultMap" type="com.lina.pojo.Team">
        <!--一般主键列用id,其余列用result
            column：表示数据库表中的列名，不区分大小写
            property：表示实体类中的对应的属性名，区分大小写
            javaType：实体类中的对应的属性的类型，可以省略，mybatis会自己推断
            jdbcType="数据库中的类型column的类型" 一般省略
        -->
        <id column="teamId" property="teamId" javaType="java.lang.Integer" ></id>
        <result column="teamName" property="teamName" javaType="java.lang.String"></result>
        <result column="location" property="location" javaType="java.lang.String"></result>
        <result column="createTime" property="createTime" javaType="java.util.Date"></result>
    </resultMap>

    <!--1、连接查询+引用关联对象的结果映射-->
    <select id="queryById1" resultMap="joinPlayMap1">
        select * from team t inner join player p
        on t.teamId=p.teamId where t.teamId=#{id}
    </select>
    <!--collection：多对映射的节点
    property：实体类中要查询的集合属性
    javaType：集合类型
    ofType:集合类型中元素的类型
    resultMap-->
    <resultMap id="joinPlayMap1" type="Team" extends="baseResultMap">
        <collection property="playerList1" javaType="arraylist" ofType="Player"
        resultMap="com.lina.mapper.PlayerMapper.baseResultMap"/>
    </resultMap>

    <!--2、使用关联对象的单独的查询语句-->
    <select id="queryById2" resultMap="joinPlayMap2">
        select * from team where teamId=#{id}
    </select>
    <resultMap id="joinPlayMap2" type="Team" extends="baseResultMap">
        <collection property="playerList2" javaType="arraylist" ofType="Player"
                    select="com.lina.mapper.PlayerMapper.queryByTeamId" column="teamId"/>
    </resultMap>


</mapper>
